
load "./perturbed_vectors.m2"

--Implementation of the deterministic and heuristic perturbed walks. 

-- The perturbed walk with perturbation factor d
-- Executes a standard Groebner walk to the perturbed vector newtau
-- Subsequently does a generic walk to Rt if newtau is not in the desired cone
perturbedWalk = method()

perturbedWalk(GroebnerBasis, Ring, ZZ) := GroebnerBasis => (G, Rt, d) -> (
    
    --input: 
    -- G = a Groebner basis
    -- Rt = a polynomial ring
    -- d = a positive integer (the perturbation factor)
    
    --output: 
    --Gt = a Groebner basis w.r.t Rt

    tau = first weightVectors Rt;
    newtau = dPerturb(weightVectors Rt, d); 
    Rnew = newRing(Rt, MonomialOrder=>{Weights => newtau});
    Gt = groebnerWalk(G, Rnew);
    if isRepresenting(Gt, tau) then return forceGB(sub(gens Gt, Rt)) else return groebnerWalk(Gt, Rt, Strategy =>Generic);
)

---

-- The heuristically perturbed walk with perturbation factor d
-- Performs a Groebner Walk to the perturbed target vector
-- Does NOT assert whether the output is a Groebner basis.

hperturbedWalk = method()

hperturbedWalk(GroebnerBasis, Ring, ZZ) := GroebnerBasis => (G, Rt, d) -> (

    -- G = a Groebner basis
    -- Rt = a polynomial ring
    -- d = a positive integer (the perturbation degree)

    -- output: 
    -- Gt: a Groebner basis of Rt (if the perturbation factor is large enough!)

    tau = first weightVectors Rt;
    newtau = dPerturb(weightVectors Rt, d); 
    Rnew = newRing(Rt, MonomialOrder=>{Weights => newtau});
    Gt = groebnerWalk(G, Rnew);
    return forceGB(sub(gens Gt, Rt));
)


--EXPERIMENTAL: The Tran Groebner Walk

TranBound = method()

TranBound(ZZ, ZZ, ZZ) := ZZ => (l, d, n) -> (
    b = 2^(2^(l-1))*d^(2^l) + 2^(2^(l+1))*d*(n+1)*(d+1)^(2^l -2)*(n+2)^(2^(l-1)-1);
    return b
    )


TranPerturbedVector = method()

TranPerturbedVector(Ring, GroebnerBasis, ZZ) := List => (R, G, l ) -> (
        -- A ring R with target monomial matrix A
        -- The starting GrÃ¶bner basis G
	    -- The number of conversions computed so far l
	
        -- returns an interior vector of the groebner cone corresponding to R


       A := weightVectors R;
       maxdeg = MaxDeg(G);
       n = numgens ring G;
       d = TranBound(l, maxdeg, n);
       w := dPerturb(A,d) 

       )

--comment: never mind. This is the DYNAMIC BOUND (supposed to make things easier. Doesn't really... )
TranWalk = method()
TranWalk(GroebnerBasis, Ring) := GroebnerBasis => (G, Rt) -> (
    -- G = a Groebner basis
    -- Rt = a polynomial ring
    -- returns Groebner basis of the ideal generated by G in the ring Rt

    R := ring G;
    w := weightVector R; -- start weight vector
    wt := weightVector Rt; -- target weight vector
    count := 0; -- count of performed conversions
    
    -- initialization (transfer G to ring with monomial order w, wt, grevlex)

    R = newRing(R, MonomialOrder=>{Weights=>w, Weights=>wt});
    G = standardStep(G, R);
    count = count + 1;


    -- step until reaching wt
    while w != wt do (

        w = nextW(G, w, wt);
	    wt =  TranPerturbedVector(R, G, count);

        R = newRing(R, MonomialOrder=>{Weights=>w, Weights=>wt});
        G = standardStep(G, R);
        count = count + 1;

        );
        )

load "./perturbed_vectors.m2" 

--versions of the Groebner walks from the "GroebnerWalk" package, with additional verbose output

verbosegenericWalk = method()
verbosegenericWalk(GroebnerBasis, Ring) := GroebnerBasis => (G, R) -> (
    -- G = a Groebner basis
    -- R = a polynomial ring
    -- returns Groebner basis of the ideal generated by G in the ring R

    S := weightVectors ring G; -- start order
    T := weightVectors R; -- target order
    count := 0; -- count of performed conversions
    lenlongestterm := 0;
    lenlongestcoeff := 0;
    
    
    

    -- find first bounding vector
    v := nextV(G, {}, S, T);
    lenlongestentry := InftyNorm(v); --keep track of largest entry of the bounding vectors 

    -- step until receiving done signal {} from nextV
    while v != {} do (
         << "Conversion Number: " << count+1 << endl
         << "Bounding Vector: " << v << endl;

	(G, a, b) = verbosegenericStep(G, v, R);
	count = count + 1;
	lenlongestterm = max({a, lenlongestterm});
    	lenlongestcoeff = max({b, lenlongestcoeff});
        
	<< "Size of new Groebner Basis: "
        << numgens ideal gens G << endl << endl;

	v = verbosenextV(G, v, S, T);
	lenlongestentry = max({lenlongestentry, InftyNorm(v)});
      	);

    -- finalization (transfer G to order in R)
        << "Total Conversions: " << count << endl;
	<< "Largest entry of a bounding vector: " << lenlongestentry << endl;
	<< "Longest support of an initial form: " << lenlongestterm << endl;
	<< "Length of longest coefficient encountered: " << lenlongestcoeff << endl;   

    -- correct for forceGB not removing content over QQ
    if coefficientRing R === QQ then (
        polys := first entries gens G;
	polys = apply(polys, f -> f/(gcd first entries gens content f));
        forceGB sub(matrix {polys}, R)
	)
    else
        forceGB sub(gens G, R)
    )

verbosegenericStep = method()
verbosegenericStep(GroebnerBasis, List, Ring) := (GroebnerBasis, ZZ, ZZ) => (G, v, R) -> (
    -- G = a Groebner basis
    -- v = bounding vector for wall of cone of G
    -- R = ring with target monomial order
    -- returns Groebner basis in next cone on generic path to R

    -- drop to gens of initial ideal at v
    inI := parallelLeadTerms(G, v);
    << "Face Codimension: " << faceCodimension inI
    << endl;
    inIlist := flatten entries inI;
    a = lenlongestpol inIlist;
    b = maxlencoeffs inIlist;
    << "Length of longest coefficient: " << maxlencoeffs(flatten entries inI) <<endl;
    << "longest support of an initial form: "<< lenlongestpol(flatten entries inI) <<endl;

    
    

    -- compute gb of initial ideal over target order
    H := gb ideal sub(inI, R);

    -- lift to new gb of ideal
    M := sub(gens H, ring G);
    
    (markedGB(sub(leadTerm H, ring G), M - M % G),  a, b) 
    
    )


verbosenextV = method()
verbosenextV(GroebnerBasis, List, List, List) := List => (G, v, S, T) -> (
    -- G = a Groebner basis
    -- v = a bounding vector of cone of G
    -- S = starting weight vectors on generic walk
    -- T = target weight vectors on generic walk
    -- returns next bounding vector on generic path from S to T

    V := unique select(boundingVectors(G), w -> any(w, i -> i < 0));

    -- select bounding vectors such that 0 <_S w
    V = select(V, w -> (for i from 0 to #S-1 do (
                            a := dot(S#i, w);
	                    if a == 0 then continue;
	                    return a > 0;
                            );
		        return false;
		       ));

    -- select bounding vectors such that w <_T 0
    V = select(V, w -> (for i from 0 to #T-1 do (
	                    a := dot(T#i, w);
			    if a == 0 then continue;
			    return a < 0;
                            );
		        return false;
		       ));

    -- except in first step, select bounding vectors greater than current v
    if #v != 0 then V = select(V, w -> isFacetLessThan(v, w, S, T));

    -- if no bounding vectors remain, return {} to signal done
    if #V == 0 then return {};

    -- find minimum v and return it
    minv := V#0;
    for i from 1 to #V-1 do (
    	if isFacetLessThan(V#i, minv, S, T) then minv = V#i;
	);
    minv
    )

verboseWalk = method()
verboseWalk(GroebnerBasis, Ring) := GroebnerBasis => (G, Rt) -> (
    -- G = a Groebner basis
    -- Rt = a polynomial ring
    -- returns Groebner basis of the ideal generated by G in the ring Rt

    R := ring G;
    w := weightVector R; -- start weight vector
    wt := weightVector Rt; -- target weight vector
    count := 0; -- count of performed conversions
    lenlongestterm := 0;
    lenlongestcoeff := 0;
    -- initialization (transfer G to ring with monomial order w, wt, grevlex)
     << "Conversion Number: " << count+1 << endl
     << "Weight Vector: " << w << endl;
    R = newRing(R, MonomialOrder=>{Weights=>w, Weights=>wt});
    G = verboseStep(G, R);
    count = count + 1;
     << "Size of new Groebner Basis: "
     << numgens ideal gens G << endl << endl;

    -- step until reaching wt
    while w != wt do (
         w = nextW(G, w, wt);
	 inwI = inw(G,w);
         << "Conversion Number: " << count+1 << endl
         << "Weight Vector: " << w << endl
	 << "Maximal length of initial forms: " << lenlongestpol(inwI)
    << endl
         << "Maximal length of coefficients: " << maxlencoeffs(inwI)
    << endl ;
    	lenlongestterm = max({lenlongestterm, lenlongestpol(inwI)});
	lenlongestcoeff = max({maxlencoeffs(inwI), lenlongestcoeff});
        R = newRing(R, MonomialOrder=>{Weights=>w, Weights=>wt});
        G = verboseStep(G, R);
        count = count + 1;
         << "Size of new Groebner Basis: "
         << numgens ideal gens G << endl << endl;
        );

    -- finalization (transfer G from monomial order wt, grevlex to order in Rt)
     << "Conversion Number: " << count+1 << endl
     << "Weight Vector: " << w << endl;
    R = newRing(Rt, MonomialOrder=>{Weights=>wt, (options Rt).MonomialOrder});
    G = verboseStep(G, R);
    count = count + 1;
    << "Size of new Groebner Basis: "
    << numgens ideal gens G << endl << endl;

     << "Total Conversions: " << count << endl
     << "Longest initial form encountered: " << lenlongestterm << endl
     << "Longest coefficient encountered: " << lenlongestcoeff << endl;
    
    -- correct for forceGB not removing content over QQ
    if coefficientRing Rt === QQ then (
        polys := first entries gens G;
	polys = apply(polys, f -> f/(gcd first entries gens content f));
        forceGB sub(matrix {polys}, Rt)
	)
    else
        forceGB sub(gens G, Rt)
    )

verboseStep = method()
verboseStep(GroebnerBasis, Ring) := GroebnerBasis => (G, R) -> (
    -- G = a Groebner basis over a ring with order compatible with w
    -- R = a ring with monomial order starting with weight w
    -- returns Groebner basis of the ideal generated by G in the ring R

    -- drop to gens of gb of initial ideal in old ring
    oldInG := leadTerm(1, sub(gens G, R));
    << "Face Codimension: " << faceCodimension oldInG
    << endl;
 

    -- cross to gens of gb of initial ideal in new ring
    newInG := gens gb ideal oldInG;

    -- lift to gb of ideal in new ring
    H := sub(newInG, ring G);
    forceGB sub(H - H % G, R)
    )

